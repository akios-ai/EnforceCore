# Copyright 2026 AKIOUD AI
# SPDX-License-Identifier: Apache-2.0
"""ComplianceReporter — v1.8.0 Compliance Reporting engine.

Turns EnforceCore audit trails into structured compliance exports for
EU AI Act, SOC2, and GDPR frameworks.

Usage::

    from enforcecore import ComplianceReporter, ComplianceFormat, CompliancePeriod

    reporter = ComplianceReporter(trail_path="audit_logs/trail.jsonl")

    period = CompliancePeriod.from_label("2026-Q4")
    report = reporter.export(ComplianceFormat.EU_AI_ACT, period)

    print(report.compliance_score)          # 0.987
    reporter.export_json(                   # write JSON to disk
        ComplianceFormat.EU_AI_ACT, period, "eu_ai_act_2026Q4.json"
    )
    reporter.export_html(                   # write HTML report
        ComplianceFormat.EU_AI_ACT, period, "eu_ai_act_2026Q4.html"
    )
    reporter.send_webhook(                  # push to Vanta / Drata
        report, url="https://app.vanta.com/api/v1/custom-tests/upload",
        token="vanta-token-..."
    )

.. versionadded:: 1.8.0
"""

from __future__ import annotations

import json
import urllib.error
import urllib.request
from datetime import UTC, datetime
from pathlib import Path
from typing import Any

import structlog

from enforcecore.compliance.types import (
    ComplianceError,
    ComplianceFormat,
    CompliancePeriod,
    ComplianceReport,
)

logger = structlog.get_logger("enforcecore.compliance")

# ---------------------------------------------------------------------------
# Template dispatch
# ---------------------------------------------------------------------------

_TEMPLATE_MODULE: dict[ComplianceFormat, str] = {
    ComplianceFormat.EU_AI_ACT: "enforcecore.compliance.templates.eu_ai_act",
    ComplianceFormat.SOC2: "enforcecore.compliance.templates.soc2",
    ComplianceFormat.GDPR: "enforcecore.compliance.templates.gdpr",
}


# ---------------------------------------------------------------------------
# HTML skeleton
# ---------------------------------------------------------------------------

_HTML_TEMPLATE = """\
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EnforceCore Compliance Report — {format_label} {period_label}</title>
  <style>
    body {{ font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
           max-width: 900px; margin: 40px auto; padding: 0 24px; color: #1a1a1a; }}
    h1 {{ border-bottom: 2px solid #0066cc; padding-bottom: 8px; }}
    .meta {{ background: #f5f5f5; border-radius: 6px; padding: 16px; margin: 16px 0; }}
    .score {{ font-size: 2em; font-weight: bold; color: {score_color}; }}
    .stat {{ display: inline-block; margin: 8px 24px 8px 0; }}
    .stat span {{ display: block; font-size: 0.85em; color: #666; }}
    .narrative {{ border-left: 4px solid #0066cc; padding: 12px 16px;
                  margin: 12px 0; background: #f0f6ff; border-radius: 0 6px 6px 0; }}
    footer {{ margin-top: 40px; font-size: 0.8em; color: #999; border-top: 1px solid #eee; padding-top: 12px; }}
  </style>
</head>
<body>
  <h1>EnforceCore Compliance Report</h1>
  <div class="meta">
    <div><strong>Framework:</strong> {format_label}</div>
    <div><strong>Period:</strong> {period_label}</div>
    <div><strong>Generated:</strong> {generated_at}</div>
    <div><strong>Policies:</strong> {policy_versions}</div>
  </div>

  <h2>Summary</h2>
  <div class="stat">
    <div class="score">{score_pct}</div>
    <span>Compliance Score</span>
  </div>
  <div class="stat">
    <strong>{total_calls}</strong><span>Total Calls</span>
  </div>
  <div class="stat">
    <strong>{violations}</strong><span>Violations Blocked</span>
  </div>
  <div class="stat">
    <strong>{pii_redactions}</strong><span>PII Redactions</span>
  </div>

  <h2>Compliance Narratives</h2>
  {narrative_blocks}

  <footer>
    Generated by <strong>EnforceCore</strong> v{version} &mdash;
    <em>This report is a technical summary. It is not a legal compliance certification.</em>
  </footer>
</body>
</html>
"""


# ---------------------------------------------------------------------------
# ComplianceReporter
# ---------------------------------------------------------------------------


class ComplianceReporter:
    """Generates structured compliance reports from an EnforceCore audit trail.

    The reporter reads a JSONL audit trail, filters entries to the requested
    :class:`~enforcecore.compliance.types.CompliancePeriod`, and produces a
    :class:`~enforcecore.compliance.types.ComplianceReport` with aggregated
    statistics and human-readable compliance narratives.

    Args:
        trail_path: Path to the JSONL audit trail file. If *None*, the reporter
            produces a zero-entry report (useful for testing without a live trail).

    .. versionadded:: 1.8.0
    """

    def __init__(self, trail_path: str | Path | None = None) -> None:
        self._trail_path: Path | None = Path(trail_path) if trail_path is not None else None
        logger.debug("ComplianceReporter initialised", trail_path=str(self._trail_path))

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def export(
        self,
        format: ComplianceFormat,
        period: CompliancePeriod,
    ) -> ComplianceReport:
        """Generate a :class:`~enforcecore.compliance.types.ComplianceReport`.

        Args:
            format: The compliance framework to report against.
            period: The reporting period.

        Returns:
            A fully populated :class:`~enforcecore.compliance.types.ComplianceReport`.

        Raises:
            :class:`~enforcecore.compliance.types.ComplianceError`: If the
                audit trail cannot be read.
        """
        entries = self._load_entries(period)
        return self._build_report(format, period, entries)

    def export_json(
        self,
        format: ComplianceFormat,
        period: CompliancePeriod,
        path: str | Path,
        *,
        indent: int = 2,
    ) -> None:
        """Export the compliance report to a JSON file.

        Args:
            format: The compliance framework.
            period: The reporting period.
            path:   Output file path (will be created/overwritten).
            indent: JSON indentation. Defaults to 2.

        Raises:
            :class:`~enforcecore.compliance.types.ComplianceError`: On I/O or
                trail-read errors.
        """
        report = self.export(format, period)
        out = Path(path)
        try:
            out.parent.mkdir(parents=True, exist_ok=True)
            out.write_text(report.to_json(indent=indent), encoding="utf-8")
        except OSError as exc:
            raise ComplianceError(f"Failed to write JSON report to {path}: {exc}") from exc
        logger.info("Compliance JSON report written", path=str(out), format=str(format))

    def export_html(
        self,
        format: ComplianceFormat,
        period: CompliancePeriod,
        path: str | Path,
    ) -> None:
        """Export the compliance report as an HTML file.

        Args:
            format: The compliance framework.
            period: The reporting period.
            path:   Output file path (will be created/overwritten).

        Raises:
            :class:`~enforcecore.compliance.types.ComplianceError`: On I/O or
                trail-read errors.
        """
        report = self.export(format, period)
        html = self._render_html(report)
        out = Path(path)
        try:
            out.parent.mkdir(parents=True, exist_ok=True)
            out.write_text(html, encoding="utf-8")
        except OSError as exc:
            raise ComplianceError(f"Failed to write HTML report to {path}: {exc}") from exc
        logger.info("Compliance HTML report written", path=str(out), format=str(format))

    def send_webhook(
        self,
        report: ComplianceReport,
        *,
        url: str,
        token: str,
        timeout: float = 10.0,
    ) -> None:
        """POST the compliance report to a webhook endpoint (Vanta, Drata, etc.).

        Sends a JSON payload via HTTP POST with a ``Bearer`` ``Authorization``
        header. Uses only stdlib ``urllib`` — no external dependencies.

        Args:
            report: The compliance report to send.
            url:    The webhook URL (e.g. Vanta custom-tests upload endpoint).
            token:  Bearer token for the ``Authorization`` header.
            timeout: HTTP timeout in seconds. Defaults to 10.

        Raises:
            :class:`~enforcecore.compliance.types.ComplianceError`: If the
                webhook call fails (network error or non-2xx response).
        """
        payload = report.to_json(indent=None).encode("utf-8")
        req = urllib.request.Request(
            url,
            data=payload,
            method="POST",
            headers={
                "Content-Type": "application/json",
                "Authorization": f"Bearer {token}",
                "User-Agent": "EnforceCore-ComplianceReporter/1.8.0",
            },
        )
        try:
            with urllib.request.urlopen(req, timeout=timeout) as resp:
                status = resp.status
        except urllib.error.HTTPError as exc:
            raise ComplianceError(
                f"Webhook POST to {url!r} returned HTTP {exc.code}: {exc.reason}"
            ) from exc
        except urllib.error.URLError as exc:
            raise ComplianceError(f"Webhook POST to {url!r} failed: {exc.reason}") from exc

        if status < 200 or status >= 300:
            raise ComplianceError(f"Webhook POST to {url!r} returned non-2xx status {status}")
        logger.info("Compliance report sent via webhook", url=url, status=status)

    # ------------------------------------------------------------------
    # Private helpers
    # ------------------------------------------------------------------

    def _load_entries(self, period: CompliancePeriod) -> list[dict[str, Any]]:
        """Load audit entries from the JSONL trail, filtered to *period*."""
        if self._trail_path is None or not self._trail_path.exists():
            return []

        entries: list[dict[str, Any]] = []
        try:
            with open(self._trail_path, encoding="utf-8") as fh:
                for raw_line in fh:
                    line = raw_line.strip()
                    if not line:
                        continue
                    try:
                        entry: dict[str, Any] = json.loads(line)
                    except json.JSONDecodeError:
                        continue
                    ts_str: str = entry.get("timestamp", "")
                    if ts_str:
                        try:
                            ts = datetime.fromisoformat(ts_str)
                            # Ensure tz-aware for comparison
                            if ts.tzinfo is None:
                                ts = ts.replace(tzinfo=UTC)
                        except ValueError:
                            continue
                        if period.contains(ts):
                            entries.append(entry)
                    else:
                        # Entry with no timestamp: include conservatively
                        entries.append(entry)
        except OSError as exc:
            raise ComplianceError(
                f"Cannot read audit trail from {self._trail_path}: {exc}"
            ) from exc

        logger.debug(
            "Loaded audit entries for compliance report",
            count=len(entries),
            period=str(period),
        )
        return entries

    def _build_report(
        self,
        format: ComplianceFormat,
        period: CompliancePeriod,
        entries: list[dict[str, Any]],
    ) -> ComplianceReport:
        """Build a :class:`~enforcecore.compliance.types.ComplianceReport` from *entries*."""
        total_calls = len(entries)
        violations = sum(1 for e in entries if e.get("decision") == "blocked")
        pii_redactions = sum(
            int(e.get("input_redactions") or 0) + int(e.get("output_redactions") or 0)
            for e in entries
        )
        policy_versions = sorted(
            {str(e["policy_version"]) for e in entries if e.get("policy_version")}
        )
        tool_names = sorted({str(e["tool_name"]) for e in entries if e.get("tool_name")})
        tenant_ids = sorted({str(e["tenant_id"]) for e in entries if e.get("tenant_id")})
        compliance_score = (total_calls - violations) / total_calls if total_calls > 0 else 1.0

        narratives = self._generate_narratives(
            format=format,
            period=period,
            total_calls=total_calls,
            violations=violations,
            pii_redactions=pii_redactions,
            tool_names=tool_names,
            policy_versions=policy_versions,
        )

        return ComplianceReport(
            format=format,
            period=period,
            generated_at=datetime.now(UTC),
            total_calls=total_calls,
            violations=violations,
            pii_redactions=pii_redactions,
            compliance_score=compliance_score,
            policy_versions=policy_versions,
            tool_names=tool_names,
            tenant_ids=tenant_ids,
            narratives=narratives,
            raw_entry_count=len(entries),
        )

    @staticmethod
    def _generate_narratives(
        *,
        format: ComplianceFormat,
        period: CompliancePeriod,
        total_calls: int,
        violations: int,
        pii_redactions: int,
        tool_names: list[str],
        policy_versions: list[str],
    ) -> list[str]:
        """Dispatch to the correct template module."""
        import importlib

        mod_name = _TEMPLATE_MODULE[format]
        mod = importlib.import_module(mod_name)
        result: list[str] = mod.generate_narratives(
            period=period,
            total_calls=total_calls,
            violations=violations,
            pii_redactions=pii_redactions,
            tool_names=tool_names,
            policy_versions=policy_versions,
        )
        return result

    @staticmethod
    def _render_html(report: ComplianceReport) -> str:
        """Render a :class:`~enforcecore.compliance.types.ComplianceReport` as HTML."""
        import enforcecore

        score_color = (
            "#00880a"
            if report.compliance_score >= 0.95
            else "#cc7700"
            if report.compliance_score >= 0.80
            else "#cc0000"
        )
        narrative_blocks = "\n  ".join(
            f'<div class="narrative">{n}</div>' for n in report.narratives
        )
        format_labels: dict[ComplianceFormat, str] = {
            ComplianceFormat.EU_AI_ACT: "EU AI Act (Article 13)",
            ComplianceFormat.SOC2: "SOC2 Type II",
            ComplianceFormat.GDPR: "GDPR (Article 30)",
        }
        return _HTML_TEMPLATE.format(
            format_label=format_labels.get(report.format, str(report.format)),
            period_label=report.period.label,
            generated_at=report.generated_at.strftime("%Y-%m-%d %H:%M:%S UTC"),
            policy_versions=", ".join(report.policy_versions) or "none",
            score_color=score_color,
            score_pct=f"{report.compliance_score:.1%}",
            total_calls=report.total_calls,
            violations=report.violations,
            pii_redactions=report.pii_redactions,
            narrative_blocks=narrative_blocks,
            version=enforcecore.__version__,
        )

    def __repr__(self) -> str:
        trail = str(self._trail_path) if self._trail_path else "none"
        return f"ComplianceReporter(trail_path={trail!r})"
